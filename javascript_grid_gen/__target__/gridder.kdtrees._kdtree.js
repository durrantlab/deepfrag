'use strict';import{AssertionError,AttributeError,BaseException,DeprecationWarning,Exception,IndexError,IterableError,KeyError,NotImplementedError,RuntimeWarning,StopIteration,UserWarning,ValueError,Warning,__JsIterator__,__PyIterator__,__Terminal__,__add__,__and__,__call__,__class__,__envir__,__eq__,__floordiv__,__ge__,__get__,__getcm__,__getitem__,__getslice__,__getsm__,__gt__,__i__,__iadd__,__iand__,__idiv__,__ijsmod__,__ilshift__,__imatmul__,__imod__,__imul__,__in__,__init__,__ior__,__ipow__,
__irshift__,__isub__,__ixor__,__jsUsePyNext__,__jsmod__,__k__,__kwargtrans__,__le__,__lshift__,__lt__,__matmul__,__mergefields__,__mergekwargtrans__,__mod__,__mul__,__ne__,__neg__,__nest__,__or__,__pow__,__pragma__,__proxy__,__pyUseJsNext__,__rshift__,__setitem__,__setproperty__,__setslice__,__sort__,__specialattrib__,__sub__,__super__,__t__,__terminal__,__truediv__,__withblock__,__xor__,abs,any,assert,bool,bytearray,bytes,callable,chr,copy,deepcopy,delattr,dict,dir,divmod,enumerate,filter,float,
getattr,hasattr,input,int,isinstance,issubclass,len,list,map,max,min,object,ord,pow,print,property,py_TypeError,py_iter,py_metatype,py_next,py_reversed,py_typeof,range,repr,round,set,setattr,sorted,str,sum,tuple,zip}from"./org.transcrypt.__runtime__.js";import{KDTreeType}from"./gridder.kdtrees._kdtree_type.js";import*as utils from"./gridder.kdtrees._utils.js";var __name__="gridder.kdtrees._kdtree";export var isin_3d=function(element,test_elements){var test_vals=set([]);for(var [x,y,z]of test_elements){test_vals.add(x);
test_vals.add(y);test_vals.add(z)}var new_elements=[];for(var [x,y,z]of element)new_elements.append([__in__(x,test_vals),__in__(y,test_vals),__in__(z,test_vals)]);return new_elements};export var isin_1d=function(element,test_elements){var test_vals=set(test_elements);var new_elements=[];for(var x of element)new_elements.append(__in__(x,test_vals));return new_elements};export var searchsorted=function(arr_1d,val){if(len(arr_1d)==0)return 0;if(arr_1d[0]>val)return 0;for(var i=0;i<len(arr_1d);i++)if(arr_1d[i]>
val)return i;return len(arr_1d)};export var all=function(lst){for(var l of lst)if(!l)return false;return true};export var col=function(pts,idx){var r=[];for(var p of pts)r.append(p[idx]);return r};export var KDTree=__class__("KDTree",[object],{__module__:__name__,get __init__(){return __get__(this,function(self,value,k,axis,accept){self.value=value;self.k=k===null?1:k;self.axis=axis===null?0:axis;self.left=null;self.right=null;self.nodes=1;self.accept=accept})},get initialize(){return function(points,
k,init_axis,accept){if(accept!==null&&!issubclass(accept,KDTreeType)){var __except0__=ValueError("Accept must be a subclass of KDTreeType");__except0__.__cause__=null;throw __except0__;}if(k===null)var k=utils.check_dimensionality(points,accept);var sorted_points=[];for(var axis=0;axis<k;axis++)sorted_points.append(sorted(points,__kwargtrans__({key:function __lambda__(x){return x[axis]}})));return KDTree._initialize_recursive(sorted_points,k,init_axis===null?0:init_axis,accept)}},get _initialize_recursive(){return function(sorted_points,
k,axis,accept){var median=Math.floor(len(sorted_points[axis])/2);var tree=KDTree(sorted_points[axis][median],k,axis,accept);var sorted_right_points=[];var sorted_left_points=[];var right_points=sorted_points[axis].__getslice__(median+1,null,1);var left_points=sorted_points[axis].__getslice__(0,median,1);for(var points of sorted_points){if(accept)print("ERROR!");else{var right_dim_masks=function(){var __accu0__=[];for(var x=0;x<k;x++)__accu0__.append(isin_1d(col(points,x),col(right_points,x)));return __accu0__}();
var right_mask=function(){var __accu0__=[];for(var x=0;x<len(right_dim_masks[0]);x++)__accu0__.append(all(col(right_dim_masks,x)));return __accu0__}();var left_dim_masks=function(){var __accu0__=[];for(var x=0;x<k;x++)__accu0__.append(isin_1d(col(points,x),col(left_points,x)));return __accu0__}();var left_mask=function(){var __accu0__=[];for(var x=0;x<len(right_dim_masks[0]);x++)__accu0__.append(all(col(left_dim_masks,x)));return __accu0__}()}sorted_right_points.append(function(){var __accu0__=[];
for(var [p,m]of zip(points,right_mask))if(m)__accu0__.append(p);return __accu0__}());sorted_left_points.append(function(){var __accu0__=[];for(var [p,m]of zip(points,left_mask))if(m)__accu0__.append(p);return __accu0__}())}var axis=axis+1<k?axis+1:0;if(len(sorted_points[axis].__getslice__(median+1,null,1))>0)tree.right=KDTree._initialize_recursive(sorted_right_points,k,axis,accept);if(len(sorted_points[axis].__getslice__(0,median,1))>0)tree.left=KDTree._initialize_recursive(sorted_left_points,k,axis,
accept);tree._recalculate_nodes();return tree}},get _recalculate_nodes(){return __get__(this,function(self){var nodes=0;if(self.right)nodes+=self.right.nodes;if(self.left)nodes+=self.left.nodes;self.nodes=nodes+1})},get nearest_neighbor(){return __get__(this,function(self,point,n,neighbors){var n=n===null?1:n;var neighbors=neighbors===null?[]:neighbors;if(self.k!=utils.check_dimensionality([point],self.accept)){var __except0__=ValueError("Point must be same dimensionality as the KDTree");__except0__.__cause__=
null;throw __except0__;}if(len(neighbors)!=n){var neighbors=[];for(var _=0;_<n;_++)neighbors.append(tuple([null,1E100]))}var dist=utils.distance(point,self.value,self.accept);var idx=searchsorted(col(neighbors,1),dist);if(idx<len(neighbors)){neighbors.insert(idx,[self.value,dist]);var neighbors=neighbors.__getslice__(0,n,1)}if(point[self.axis]+neighbors[len(neighbors)-1][1]>=self.value[self.axis]&&self.right)var neighbors=self.right.nearest_neighbor(point,n,neighbors);if(point[self.axis]-neighbors[len(neighbors)-
1][1]<self.value[self.axis]&&self.left)var neighbors=self.left.nearest_neighbor(point,n,neighbors);return neighbors})},get proximal_neighbor(){return __get__(this,function(self,point,d,neighbors){var d=d===null?0:d;var neighbors=neighbors===null?[]:neighbors;if(self.k!=utils.check_dimensionality([point],self.accept)){var __except0__=ValueError("Point must be same dimensionality as the KDTree");__except0__.__cause__=null;throw __except0__;}var dist=utils.distance(point,self.value,self.accept);if(dist<=
d)if(len(neighbors)>0){var idx=searchsorted(col(neighbors,1),dist);neighbors.insert(idx,[self.value,dist])}else var neighbors=[[self.value,dist]];if(self.right&&point[self.axis]+d>=self.value[self.axis])var neighbors=self.right.proximal_neighbor(point,d,neighbors);if(self.left&&point[self.axis]-d<self.value[self.axis])var neighbors=self.left.proximal_neighbor(point,d,neighbors);return neighbors})}});

//# sourceMappingURL=gridder.kdtrees._kdtree.map