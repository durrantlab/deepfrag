'use strict';var math={};import{AssertionError,AttributeError,BaseException,DeprecationWarning,Exception,IndexError,IterableError,KeyError,NotImplementedError,RuntimeWarning,StopIteration,UserWarning,ValueError,Warning,__JsIterator__,__PyIterator__,__Terminal__,__add__,__and__,__call__,__class__,__envir__,__eq__,__floordiv__,__ge__,__get__,__getcm__,__getitem__,__getslice__,__getsm__,__gt__,__i__,__iadd__,__iand__,__idiv__,__ijsmod__,__ilshift__,__imatmul__,__imod__,__imul__,__in__,__init__,__ior__,
__ipow__,__irshift__,__isub__,__ixor__,__jsUsePyNext__,__jsmod__,__k__,__kwargtrans__,__le__,__lshift__,__lt__,__matmul__,__mergefields__,__mergekwargtrans__,__mod__,__mul__,__ne__,__neg__,__nest__,__or__,__pow__,__pragma__,__proxy__,__pyUseJsNext__,__rshift__,__setitem__,__setproperty__,__setslice__,__sort__,__specialattrib__,__sub__,__super__,__t__,__terminal__,__truediv__,__withblock__,__xor__,abs,all,any,assert,bool,bytearray,bytes,callable,chr,copy,deepcopy,delattr,dict,dir,divmod,enumerate,
filter,float,getattr,hasattr,input,int,isinstance,issubclass,len,list,map,max,min,object,ord,pow,print,property,py_TypeError,py_iter,py_metatype,py_next,py_reversed,py_typeof,range,repr,round,set,setattr,sorted,str,sum,tuple,zip}from"./org.transcrypt.__runtime__.js";import*as __module_math__ from"./math.js";__nest__(math,"",__module_math__);var __name__="gridder.kdtrees._utils";export var check_dimensionality=function(points,accept){var accept=false;if(len(points)==0){var __except0__=ValueError("Must contain at least one argument");
__except0__.__cause__=null;throw __except0__;}try{if(accept)var dims=function(){var __accu0__=[];for(var a of points)__accu0__.append(a.dim);return __accu0__}();else var dims=function(){var __accu0__=[];for(var a of points)__accu0__.append(len(a));return __accu0__}();var dim=dims[0];return dim}catch(__except0__){if(isinstance(__except0__,AttributeError)){print(points);var __except1__=AttributeError("Arguments must contain attribute `dim`");__except1__.__cause__=null;throw __except1__;}else throw __except0__;
}};export var distance=function(obj1,obj2,accept){if(accept){if(isinstance(obj1,accept)&&isinstance(obj2,accept))return obj1.distance(obj2);var __except0__=ValueError("`obj1` and `obj2` must be the same type as `accept`");__except0__.__cause__=null;throw __except0__;}else{var diffs=function(){var __accu0__=[];for(var [x,y]of zip(obj1,obj2))__accu0__.append(x-y);return __accu0__}();var d=sum(function(){var __accu0__=[];for(var d of diffs)__accu0__.append(d*d);return __accu0__}());return d}};

//# sourceMappingURL=gridder.kdtrees._utils.map