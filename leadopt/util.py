'''
rdkit utility scripts
'''
from rdkit import Chem
import numpy as np


def combine_all(frags):
    '''
    combine a list of rdkit mols
    '''
    if len(frags) == 0:
        return None
    
    c = frags[0]
    for f in frags[1:]:
        c = Chem.CombineMols(c,f)
        
    return c


def generate_fragments(mol, max_heavy_atoms=0, only_single_bonds=True):
    """
    Takes an rdkit molecule and returns a list of (parent, fragment) tuples

    Inputs:
    :param rdkit.Chem.rdchem.Mol mol: The molecule to fragment.
    :param int max_heavy_atoms: The maximum number of heavy atoms to include 
        in generated fragments.
    :param bool only_single_bonds: If set to true, this method will only return
        fragments generated by breaking single bonds.

    Returns:
    :returns: list of (parent, fragment) tuples where mol is larger than fragment.
    """
    # list of (parent, fragment) tuples
    splits = []

    # if we have multiple ligands already, split into pieces and then iterate
    ligands = Chem.GetMolFrags(mol, asMols=True, sanitizeFrags=False)
    
    for i in range(len(ligands)):
        lig = ligands[i]
        other = list(ligands[:i] + ligands[i+1:])
        
        # iterate over bonds
        for i in range(lig.GetNumBonds()):
            # (optional) filter base on single bonds
            if only_single_bonds and lig.GetBondWithIdx(i).GetBondType() != Chem.rdchem.BondType.SINGLE:
                continue

            # split the molecule
            split_mol = Chem.rdmolops.FragmentOnBonds(lig, [i])

            # obtain fragments
            fragments = Chem.GetMolFrags(split_mol, asMols=True, sanitizeFrags=False)

            # skip if this did not break the molecule into two pieces
            if len(fragments) != 2:
                continue

            # otherwise make sure the first fragment is larger
            if fragments[0].GetNumAtoms() < fragments[1].GetNumAtoms():
                fragments = fragments[::-1]

            # make sure the fragment has at least one heavy atom
            if fragments[1].GetNumHeavyAtoms() == 0:
                continue

            # (optional) filter based on number of heavy atoms in the fragment
            if max_heavy_atoms > 0 and fragments[1].GetNumHeavyAtoms() > max_heavy_atoms:
                continue
                
            # if we have other ligands present, merge them with the parent
            parent = fragments[0]
            
            if len(other) > 0:
                parent = combine_all([parent] + other)

            # add this pair
            splits.append((parent, fragments[1]))

    return splits


def load_ligand(sdf):
    '''load and fragment ligand'''
    lig = next(Chem.SDMolSupplier(sdf, sanitize=False))
    frags = generate_fragments(lig)
    
    return lig, frags


def remove_water(m):
    '''remove water from an rdkit mol'''
    parts = Chem.GetMolFrags(m, asMols=True, sanitizeFrags=False)
    valid = [k for k in parts if not Chem.MolToSmiles(k, allHsExplicit=True) == '[OH2]']
    
    assert len(valid) > 0, 'error: molecule contains only water'
    
    merged = valid[0]
    for part in valid[1:]:
        merged = Chem.CombineMols(merged, part)
        
    return merged


def load_receptor(rec_path):
    '''load a pdb file and clean it up'''
    rec = Chem.MolFromPDBFile(rec_path, sanitize=False)
    rec = remove_water(rec)
    
    return rec


def get_connection_point(frag):
    '''return the coordinates of the dummy atom as a numpy array [x,y,z]'''
    dummy_idx = [k.GetAtomicNum() for k in frag.GetAtoms()].index(0)
    coords = frag.GetConformer().GetPositions()[dummy_idx]
    
    return coords


def frag_dist_to_receptor(rec, frag):
    '''compute the minimum distance between the fragment connection point any receptor atom'''
    rec_coords = rec.GetConformer().GetPositions()
    conn = get_connection_point(frag)
    
    # compute pairwise distances
    dist = np.sum((rec_coords - conn) ** 2, axis=1)
    min_dist = np.sqrt(np.min(dist))
    
    return min_dist


def mol_array(mol):
    '''convert an rdkit mol to an array of coordinates and atom types'''
    coords = mol.GetConformer().GetPositions()
    types = np.array([k.GetAtomicNum() for k in mol.GetAtoms()]).reshape(-1,1)

    arr = np.concatenate([coords, types], axis=1)

    return arr


def mol_to_points(mol, atom_types=[6,7,8,9,15,16,17,35,53]):
    '''convert an rdkit mol to an array of coordinates and layers'''
    coords = mol.GetConformer().GetPositions()
    types = [k.GetAtomicNum() for k in mol.GetAtoms()]
    layers = np.array([(atom_types.index(k) if k in atom_types else -1) for k in types])
    
    # filter by existing layer
    coords = coords[layers != -1]
    layers = layers[layers != -1].reshape(-1,1)
    
    return coords, layers


def merge_smiles(sma, smb):
    '''merge two smile frament strings by combining at the dummy connection point'''
    a = Chem.MolFromSmiles(sma, sanitize=False)
    b = Chem.MolFromSmiles(smb, sanitize=False)

    # merge molecules
    c = Chem.CombineMols(a,b)

    # find dummy atoms
    da,db = np.where(np.array([k.GetAtomicNum() for k in c.GetAtoms()]) == 0)[0]

    # find neighbors to connect
    na = c.GetAtomWithIdx(int(da)).GetNeighbors()[0].GetIdx()
    nb = c.GetAtomWithIdx(int(db)).GetNeighbors()[0].GetIdx()

    e = Chem.EditableMol(c)
    for d in sorted([da,db])[::-1]:
        e.RemoveAtom(int(d))

    # adjust atom indexes
    na -= int(da < na) + int(db < na)
    nb -= int(da < nb) + int(db < nb)

    e.AddBond(na,nb,Chem.rdchem.BondType.SINGLE)

    r = e.GetMol()
    
    sm = Chem.MolToSmiles(Chem.RemoveHs(r, sanitize=False))
    
    return sm
